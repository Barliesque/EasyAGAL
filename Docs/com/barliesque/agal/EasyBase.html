<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../../override.css" type="text/css"><meta name="keywords" content="EasyBase,com.barliesque.agal.EasyBase,ATTRIBUTE,ATTRIBUTE,CONST,CONST,FCONST_COUNT,FILTER_LINEAR,FILTER_NEAREST,MIP_LINEAR,MIP_NEAREST,MIP_NONE,MIP_NO,MODE_CLAMP,MODE_REPEAT,MODE_WRAP,OUTPUT,OUTPUT,OUTPUT_COUNT,SAMPLER,SAMPLER,SAMPLER_COUNT,SPECIAL_CENTROID,SPECIAL_DEPTH,SPECIAL_SINGLE,TEMP,TEMP,TEMP_COUNT,TYPE_2D,TYPE_3D,TYPE_CUBE,VARYING,VARYING,VARYING_COUNT,VCONST_COUNT,a,b,context,fragmentInstructions,g,program,r,rgb,vertexInstructions,w,x,xyz,y,z,CONST_byIndex,_,_fragmentShader,_vertexShader,abs,abs,add,add,comment,cos,cos,crossProduct,crs,dispose,div,divide,dotProduct3,dotProduct4,dp3,dp4,exp,exp,fractional,frc,getCount,getFragmentOpcode,getType,getVertexOpcode,kil,killFragment,log,log,m33,m34,m44,max,max,min,min,mov,move,mul,multiply,multiply3x3,multiply3x4,multiply4x4,neg,negate,nextRegister,normalize,nrm,pow,pow,rcp,reciprocal,reciprocalRoot,rsq,sampleTexture,sat,saturate,seq,setContext,setFragmentOpcode,setIf_Equal,setIf_GreaterEqual,setIf_LessThan,setIf_NotEqual,setProgram,setVertexOpcode,sge,sin,sin,slt,sne,sqt,squareRoot,sub,subtract,tex,upload"><title>com.barliesque.agal.EasyBase</title></head><body><script language="javascript" type="text/javascript" src="../../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../../help.js"></script><script language="javascript" type="text/javascript" src="../../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'EasyBase - API Documentation';
				var baseRef = '../../../';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">EasyAGAL - An easier way to write AGAL shaders</td><td class="titleTableTopNav" align="right"><a href="../../../package-summary.html" onclick="loadClassListFrame('../../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../../class-summary.html" onclick="loadClassListFrame('../../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../../all-index-A.html" onclick="loadClassListFrame('../../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../../index.html?com/barliesque/agal/EasyBase.html&amp;com/barliesque/agal/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">EasyBase</td><td class="titleTableSubNav" id="subNav" align="right"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("EasyBase"); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,false,false	,false,false,false,false,false);}	
				-->
			</script><div xmlns:fn="http://www.w3.org/2005/xpath-functions" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Package</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">com.barliesque.agal</a></td></tr><tr><td class="classHeaderTableLabel">Class</td><td class="classSignature">public  class  EasyBase</td></tr><tr><td class="classHeaderTableLabel">Inheritance</td><td class="inheritanceList">EasyBase  <img src="../../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> Object</td></tr><tr><td class="classHeaderTableLabel">Subclasses</td><td> <a href="../../../com/barliesque/agal/EasierAGAL.html">EasierAGAL</a>,  <a href="../../../com/barliesque/agal/EasyAGAL.html">EasyAGAL</a></td></tr></table><p></p><p></p><p></p>
	 Internal base class providing common functionality of EasyAGAL and EasierAGAL
	 <p></p><br/><hr></div><a name="propertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#context" class="signatureLink">context</a> : Context3D<div class="summaryTableDescription">[read-only]  The Context3D instance the shader program has been uploaded to.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#fragmentInstructions" class="signatureLink">fragmentInstructions</a> : uint<div class="summaryTableDescription">[read-only] 
		 A count of the number of instructions in the fragment shader.
		 AGAL shaders are restricted to a max of 200 instructions.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#program" class="signatureLink">program</a> : Program3D<div class="summaryTableDescription">[read-only]  The Program3D instance created by calling upload()  </div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#vertexInstructions" class="signatureLink">vertexInstructions</a> : uint<div class="summaryTableDescription">[read-only] 
		 A count of the number of instructions in the vertex shader.
		 AGAL shaders are restricted to a max of 200 instructions.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr></table></div><a name="protectedPropertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Protected Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProtectedProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#ATTRIBUTE" class="signatureLink">ATTRIBUTE</a> : Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;<div class="summaryTableDescription">[read-only] 
		 { va0-7 }  VERTEX ATTRIBUTE BUFFER REGISTERS
		 These registers hold up to eight different attributes of the current vertex
		 being processed.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#CONST" class="signatureLink">CONST</a> : Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;<div class="summaryTableDescription">[read-only] 
		 { vc0-127 / fc0-27 }  CONSTANT REGISTERS
		 These hold read-only values, passed as parameters from ActionScript using Context3D::setProgramConstants().</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#OUTPUT" class="signatureLink">OUTPUT</a> : <a href="../../../com/barliesque/agal/IRegister.html">IRegister</a><div class="summaryTableDescription">[read-only] 
		 { op / oc }  OUTPUT REGISTER - Position or Color
		 The output register is where the result of the shader must be stored.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#SAMPLER" class="signatureLink">SAMPLER</a> : Vector.&lt;<a href="../../../com/barliesque/agal/ISampler.html">ISampler</a>&gt;<div class="summaryTableDescription">[read-only] 
		 { fs0-7 }  FRAGMENT (TEXTURE) SAMPLER REGISTERS
		 The Sampler registers are used to pick color values from textures,
		 based on UV coordinates.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#TEMP" class="signatureLink">TEMP</a> : Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;<div class="summaryTableDescription">[read-only] 
		 { vt0-7 / ft0-7 }  TEMPORARY REGISTERS
		 These registers are where most operations are carried out.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#VARYING" class="signatureLink">VARYING</a> : Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;<div class="summaryTableDescription">[read-only] 
		 { v0-7 }  VARYING REGISTERS
		 Used to pass data from the vertex shader to the fragment shader.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr></table></div><a name="methodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#EasyBase()" class="signatureLink">EasyBase</a>(debug:Boolean = true, assemblyDebug:Boolean = false)</div><div class="summaryTableDescription">
		 </div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#dispose()" class="signatureLink">dispose</a>():void</div><div class="summaryTableDescription">
		 Release all resources, including the shader program uploaded to the GPU.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getFragmentOpcode()" class="signatureLink">getFragmentOpcode</a>(lineNumbering:Boolean = false, formatAS3:Boolean = false):String</div><div class="summaryTableDescription">
		 Returns fragment shader code to be passed to AGALMiniAssembler.
		 If _fragmentShader() has not already been called, it will be called now.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getVertexOpcode()" class="signatureLink">getVertexOpcode</a>(lineNumbering:Boolean = false, formatAS3:Boolean = false):String</div><div class="summaryTableDescription">
		 Returns vertex shader code to be passed to AGALMiniAssembler.
		 If _vertexShader() has not already been called, it will be called now.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#upload()" class="signatureLink">upload</a>(context:Context3D):Program3D</div><div class="summaryTableDescription">
		 Assemble and upload the shader program.
		 Note:  The shader will only be assembled and uploaded if the 'program' property of this instance is null.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr></table></div><a name="protectedMethodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Protected Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProtectedMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#_fragmentShader()" class="signatureLink">_fragmentShader</a>():void</div><div class="summaryTableDescription">
		 To be overridden.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#_vertexShader()" class="signatureLink">_vertexShader</a>():void</div><div class="summaryTableDescription">
		 To be overridden.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#comment()" class="signatureLink">comment</a>(... remarks):void</div><div class="summaryTableDescription">[static] 
		 Add a comment to the opcode.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#CONST_byIndex()" class="signatureLink">CONST_byIndex</a>(index:<a href="../../../com/barliesque/agal/IComponent.html">IComponent</a>):<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a></div><div class="summaryTableDescription">
		 { vc[] }  Use a register component to specify the index of a CONSTANT register.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setContext()" class="signatureLink">setContext</a>(context:Context3D):void</div><div class="summaryTableDescription"> Use this function to manually assign a context.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setFragmentOpcode()" class="signatureLink">setFragmentOpcode</a>(opcode:String, append:Boolean = false):void</div><div class="summaryTableDescription">
		 Use this function to manually assign, clear or append to the fragment opcode
		 Note:  Unless debug is true (set by EasyAGAL/EasierAGAL constructor) the opcode count will not be updated.
		 </div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setProgram()" class="signatureLink">setProgram</a>(value:Program3D):void</div><div class="summaryTableDescription"> Use this function to manually assign or clear the shader program.</div></td><td class="summaryTableOwnerCol">EasyBase</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#setVertexOpcode()" class="signatureLink">setVertexOpcode</a>(opcode:String, append:Boolean = false):void</div><div class="summaryTableDescription">
		 Use this function to manually assign, clear or append to the vertex opcode
		 Note:  Unless debug is true (set by EasyAGAL/EasierAGAL constructor) the opcode count will not be updated.
		 </div></td><td class="summaryTableOwnerCol">EasyBase</td></tr></table></div><script language="javascript" type="text/javascript"><!--
										showHideInherited();
										--></script><div class="MainContent"><div class="detailSectionHeader">Property Detail</div><a name="propertyDetail"></a><a name="ATTRIBUTE"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">ATTRIBUTE</td><td class="detailHeaderType">property</td></tr></table><div class="detailBody"><code>ATTRIBUTE:Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ va0-7 }  VERTEX ATTRIBUTE BUFFER REGISTERS</p>
		 <p>These registers hold up to eight different attributes of the current vertex
		 being processed.  Vertex Attribute registers are only available in vertex shaders.
		 Data is passed by ActionScript using the function Context3D::setVertexBufferAt().
		 Attributes of a vertex will probably include position, as well as UV texture values, 
		 vertex color, vertex normal, or any other information that your shader can make use of.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get ATTRIBUTE():Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code><br/></div><a name="propertyDetail"></a><a name="CONST"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">CONST</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>CONST:Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ vc0-127 / fc0-27 }  CONSTANT REGISTERS</p>
		 <p>These hold read-only values, passed as parameters from ActionScript using Context3D::setProgramConstants().
		 There are 128 constants available to vertex shaders, but only 28 to fragment shaders.</p>
		 <p>Constant registers may not be used as the sole input of a calculation.  
		 You can not, for instance, add two Constant registers together.  There are two alternatives:</p>
		 <p>1) Pre-calculate and pass the resulting value in another Constant register.  (Usually preferred)</p>
		 <p>2) Move one Constant register's value to a Temp register, and then perform the calculation.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get CONST():Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code><br/></div><a name="propertyDetail"></a><a name="context"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">context</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>context:Context3D</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> The Context3D instance the shader program has been uploaded to.  Set by calling upload().  Cleared by calling dispose(). </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get context():Context3D</code><br/></div><a name="propertyDetail"></a><a name="fragmentInstructions"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">fragmentInstructions</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>fragmentInstructions:uint</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>A count of the number of instructions in the fragment shader.</p>
		 <p>AGAL shaders are restricted to a max of 200 instructions.
		 If _fragmentShader() has not already been called, it will be called upon access of this property.
		 It is safe to access this property from _fragmentShader() without causing an infinite loop.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get fragmentInstructions():uint</code><br/><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#_fragmentShader()" target="">_fragmentShader()</a></div></div><a name="propertyDetail"></a><a name="OUTPUT"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">OUTPUT</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>OUTPUT:<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a></code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ op / oc }  OUTPUT REGISTER - Position or Color</p>
		 <p>The output register is where the result of the shader must be stored.
		 For vertex shaders, this output is the clip-space position of the vertex.
		 For fragment shaders it is the color of the pixel.
		 There is only one Output register for the vertex shader and one for the fragment shader.
		 The Output register is write-only.</p>
		 <p>For more about the clip-space coordinate system, see:  http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter04.html</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get OUTPUT():<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a></code><br/></div><a name="propertyDetail"></a><a name="program"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">program</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>program:Program3D</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p> The Program3D instance created by calling upload()  </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get program():Program3D</code><br/></div><a name="propertyDetail"></a><a name="SAMPLER"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">SAMPLER</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>SAMPLER:Vector.&lt;<a href="../../../com/barliesque/agal/ISampler.html">ISampler</a>&gt;</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ fs0-7 }  FRAGMENT (TEXTURE) SAMPLER REGISTERS</p>
		 <p>The Sampler registers are used to pick color values from textures,
		 based on UV coordinates.  Texture images are passed from Actionscript with 
		 the function Context3D::setTextureAt(index:uint, texture:BitmapData) where
		 the index corresponds to the Fragment Sampler register number.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get SAMPLER():Vector.&lt;<a href="../../../com/barliesque/agal/ISampler.html">ISampler</a>&gt;</code><br/></div><a name="propertyDetail"></a><a name="TEMP"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">TEMP</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>TEMP:Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ vt0-7 / ft0-7 }  TEMPORARY REGISTERS</p>
		 <p>These registers are where most operations are carried out.  The Temp registers are read and write enabled, 
		 and allow you to temporarily store the results of calculations.
		 There are 8 temporary registers available to vertex shaders, and another 8 to pixel shaders.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get TEMP():Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code><br/></div><a name="propertyDetail"></a><a name="VARYING"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">VARYING</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>VARYING:Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>{ v0-7 }  VARYING REGISTERS</p>
		 <p>Used to pass data from the vertex shader to the fragment shader.
		 When the fragment shader is run, these registers will contain interpolations
		 of the values passed by the vertex shader for each vertex of the polygon
		 of which the fragment is a part.
		 There are 8 Varying registers, shared by both vector and fragment shaders.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected function get VARYING():Vector.&lt;<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a>&gt;</code><br/></div><a name="propertyDetail"></a><a name="vertexInstructions"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">vertexInstructions</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>vertexInstructions:uint</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 <p>A count of the number of instructions in the vertex shader.</p>
		 <p>AGAL shaders are restricted to a max of 200 instructions.
		 If _vertexShader() has not already been called, it will be called upon access of this property.
		 It is safe to access this property from _vertexShader() without causing an infinite loop.</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get vertexInstructions():uint</code><br/><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#_vertexShader()" target="">_vertexShader()</a></div></div><a name="constructorDetail"></a><div class="detailSectionHeader">Constructor Detail</div><a name="EasyBase()"></a><a name="EasyBase(Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">EasyBase</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Constructor</td></tr></table><div class="detailBody"><code>public function EasyBase(debug:Boolean = true, assemblyDebug:Boolean = false)</code><p></p><p>
		 </p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">debug</span>:Boolean</code> (default = <code>true</code>)<code></code> &mdash; 			Set to true to enable comments to be added to opcode, and opcode trace upon rejection of program upload.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">assemblyDebug</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; 	Set to true for opcode output from AGALMiniAssembler
		 </td></tr></table></div><a name="methodDetail"></a><div class="detailSectionHeader">Method Detail</div><a name="_fragmentShader()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">_fragmentShader</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td></tr></table><div class="detailBody"><code> protected function _fragmentShader():void</code><p></p><p></p><p>
		 <p>To be overridden.  Write your fragment shader here.</p>
		 <p>This function is called internally when the shader program needs to prepared and assembled.
		 By extending and using the functions found in either EasyAGAL or EasierAGAL, both of which extend this class, 
		 write your Fragment Shader program within this function.</p>
		 <p>Note: If opcode has already been assigned to 'fragmentOpcode' then that code will be used, and this function will not be called.</p>
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#setFragmentOpcode()" target="">setFragmentOpcode()</a></div></div><a name="_vertexShader()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">_vertexShader</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function _vertexShader():void</code><p></p><p></p><p>
		 <p>To be overridden.  Write your vertex shader here.</p>
		 <p>This function is called internally when the shader program needs to prepared and assembled.
		 By extending and using the functions found in either EasyAGAL or EasierAGAL, both of which extend this class, 
		 write your Vertex Shader program within this function.</p>
		 <p>Note: If opcode has already been assigned to 'vertexOpcode' then that code will be used, and this function will not be called.</p>
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#setVertexOpcode()" target="">setVertexOpcode()</a></div></div><a name="comment()"></a><a name="comment(restParam)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">comment</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected static function comment(... remarks):void</code><p></p><p></p><p>
		 Add a comment to the opcode.  Helpful if you want to examine the opcode constructed by EasyAGAL.
		 Commenting is disabled when EasyBase::debug is set to false.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code>... <span class="label">remarks</span></code> &mdash; 	Comments to be included with the opcode.  Multiple remarks will appear as multi-line comments.
		 </td></tr></table></p></div><a name="CONST_byIndex()"></a><a name="CONST_byIndex(com.barliesque.agal.IComponent)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">CONST_byIndex</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function CONST_byIndex(index:<a href="../../../com/barliesque/agal/IComponent.html">IComponent</a>):<a href="../../../com/barliesque/agal/IRegister.html">IRegister</a></code><p></p><p></p><p>
		 { vc[] }  Use a register component to specify the index of a CONSTANT register.
		 Available only in vertex shaders.
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">index</span>:<a href="../../../com/barliesque/agal/IComponent.html">IComponent</a></code></td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../../com/barliesque/agal/IRegister.html">IRegister</a></code> &mdash; Returns a CONST register in the format:  vc[vt0.x]  or  fc[ft3.y]
		 </td></tr></table></div><a name="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dispose</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():void</code><p></p><p></p><p>
		 Release all resources, including the shader program uploaded to the GPU.
		 Calling upload() after dispose() has been called will result in the shader being recompiled and uploaded.
		 </p><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#upload()" target="">upload()</a></div></div><a name="getFragmentOpcode()"></a><a name="getFragmentOpcode(Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getFragmentOpcode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getFragmentOpcode(lineNumbering:Boolean = false, formatAS3:Boolean = false):String</code><p></p><p></p><p>
		 <p>Returns fragment shader code to be passed to AGALMiniAssembler.</p>
		 <p>If _fragmentShader() has not already been called, it will be called now.
		 It is safe to call this function from within _fragmentShader() without causing an infinite loop.</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">lineNumbering</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If true, line numbers are added to the left side to assist in locating tokens referred to by an AGAL error message
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">formatAS3</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; 	If true, the result will be formatted as AS3 code that can be used in place of EasyAGAL instructions for faster processing.
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; Returns fragment shader code to be passed to AGALMiniAssembler
		 </td></tr></table><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#_fragmentShader()" target="">_fragmentShader()</a><br/><a href="EasyBase.html#setFragmentOpcode()" target="">setFragmentOpcode()</a></div></div><a name="getVertexOpcode()"></a><a name="getVertexOpcode(Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getVertexOpcode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVertexOpcode(lineNumbering:Boolean = false, formatAS3:Boolean = false):String</code><p></p><p></p><p>
		 <p>Returns vertex shader code to be passed to AGALMiniAssembler.</p>
		 <p>If _vertexShader() has not already been called, it will be called now.
		 It is safe to call this function from within _vertexShader() without causing an infinite loop.</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">lineNumbering</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; If true, line numbers are added to assist in locating tokens referred to by an AGAL error message
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">formatAS3</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; 	If true, the result will be formatted as AS3 code that can be used in place of EasyAGAL instructions for faster processing.
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; Returns vertex shader code to be passed to AGALMiniAssembler
		 </td></tr></table><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#_vertexShader()" target="">_vertexShader()</a><br/><a href="EasyBase.html#setFragmentOpcode()" target="">setFragmentOpcode()</a></div></div><a name="setContext()"></a><a name="setContext(flash.display3D.Context3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setContext</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function setContext(context:Context3D):void</code><p></p><p></p><p> Use this function to manually assign a context. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">context</span>:Context3D</code></td></tr></table></p></div><a name="setFragmentOpcode()"></a><a name="setFragmentOpcode(String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setFragmentOpcode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function setFragmentOpcode(opcode:String, append:Boolean = false):void</code><p></p><p></p><p>
		 <p>Use this function to manually assign, clear or append to the fragment opcode</p>
		 <p>Note:  Unless debug is true (set by EasyAGAL/EasierAGAL constructor) the opcode count will not be updated.</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">opcode</span>:String</code> &mdash; 	A string to be assigned or appended to the fragment opcode.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">append</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; 	True to append to the existing opcode, false to replace it.  (Default is false)
		 </td></tr></table></p><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#getFragmeentOpcode()" target="">getFragmeentOpcode()</a><br/><a href="EasyBase.html#_fragmentShader()" target="">_fragmentShader()</a></div></div><a name="setProgram()"></a><a name="setProgram(flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setProgram</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function setProgram(value:Program3D):void</code><p></p><p></p><p> Use this function to manually assign or clear the shader program. </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:Program3D</code></td></tr></table></p></div><a name="setVertexOpcode()"></a><a name="setVertexOpcode(String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">setVertexOpcode</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> protected function setVertexOpcode(opcode:String, append:Boolean = false):void</code><p></p><p></p><p>
		 <p>Use this function to manually assign, clear or append to the vertex opcode</p>
		 <p>Note:  Unless debug is true (set by EasyAGAL/EasierAGAL constructor) the opcode count will not be updated.</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">opcode</span>:String</code> &mdash; 	A string to be assigned or appended to the vertex opcode.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">append</span>:Boolean</code> (default = <code>false</code>)<code></code> &mdash; 	True to append to the existing opcode, false to replace it.  (Default is false)
		 </td></tr></table></p><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#getVertexOpcode()" target="">getVertexOpcode()</a><br/><a href="EasyBase.html#_vertexShader()" target="">_vertexShader()</a></div></div><a name="upload()"></a><a name="upload(flash.display3D.Context3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">upload</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function upload(context:Context3D):Program3D</code><p></p><p></p><p>
		 <p>Assemble and upload the shader program.</p>
		 <p>Note:  The shader will only be assembled and uploaded if the 'program' property of this instance is null.
		 In order to reassemble and re-upload the program, dispose() should be called first.</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">context</span>:Context3D</code> &mdash; 	The Context3D instance that will use this shader
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Program3D</code> &mdash; Returns a reference to the Program3D instance
		 </td></tr></table><p><span class="label">See also</span></p><div class="seeAlso"><a href="EasyBase.html#dispose()" target="">dispose()</a></div></div><br/><br/><hr><br/><p></p><center class="copyright"><footer></footer><br/>Sat Nov 5 2011, 08:08 PM -07:00  </center></div></body></html><!--<br/>Sat Nov 5 2011, 08:08 PM -07:00  -->